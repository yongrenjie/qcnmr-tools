#!/usr/bin/env python3

# This script performs DP4 analysis as described in Smith & Goodman, J. Am. Chem. Soc. 2010, 132 (37), 12946–12959.
#
# The script requires two text files: dp4_calc.txt (containing the calculated shifts) and dp4_expt.txt (experimental
# shifts). Both files must have the following format:
#  - first a header line containing the names of the two isomers (e.g. for calculated shifts, you may want to specify
#    here the connectivity or configuration of the molecule). The names must not contain any spaces, but whitespace
#    before or after the names is fine.
#  - the subsequent lines must contain: (1) an atom label which begins with either 'C', 'c', 'H', or 'h'; (2) the shifts
#    for each isomer.
#  - comment lines beginning with # are allowed, but only after the header line.
#
# In both dp4_calc.txt and dp4_expt.txt, the atom labels MUST align exactly! Both files can be generated by copy-pasting
# relevant cells from Excel into vim / other text editors directly. See dp4_calc.txt and dp4_expt.txt in this folder for
# a real-life example.
#
# If desired, the output can be printed to a file: use "dp4.py > dp4.out" instead of just "dp4.py".
#
# The file dp4_expt.txt may contain more than two columns of shifts. In this case, the program will perform DP4 analysis
# for every column - isn't that amazing?
#
# The DOF and standard deviations for the t-distributions used in the DP4 method are obtained unchanged from Goodman's
# paper. Please note that in theory, these numbers are sensitive to the method used and the training set.

import pandas as pd
from scipy import stats
import sys

# define degrees of freedom and standard deviations for t-distributions, as reported in main text of paper
DF_1H = 14.18
SD_1H = 0.185
DF_13C = 11.38
SD_13C = 2.306

# control how precise the output should be (i.e. how many decimal places). 11 is a good number.
# Don't decrease this below 8, or fmt_float will crash.
output_precision = 11


def error_quit(error_message):
    print()
    print("ERROR: {}".format(error_message))
    print("Exiting...")
    sys.exit()


def fmt_float(fl, desired_length):
    # Trims a float to a certain length and displays it in scientific notation if it's tiny.
    # This returns a string, not a float!
    if -0.0001 < fl < 0.0001 and fl != 0:
        return "{:{}.{}e}".format(fl, desired_length, desired_length - 8)
    else:
        return "{:{}.{}f}".format(fl, desired_length, desired_length - 4)


def fmt_string(st, desired_length):
    # Trims a string to a certain length, or pads it with spaces if it's shorter than that
    if len(st) < desired_length:
        return st + " " * (desired_length - len(st))
    else:
        return st[0:desired_length]


def calculate_dp4_probability(atoms, stars, expt, calc):
    # Returns the product of probabilities of observing the errors in chemical shifts, i.e. P of getting the calculated
    # shifts given the experimental shifts, or P(DP4|A) where A is a specific assignment.
    # More precisely, this returns a list of the 13C, 1H, and combined DP4 probabilities, in that order.
    # Note that this is _not_ the probability of an isomer being the correct one!

    # some code to sort any shifts with asterisks
    for i in range(max(stars)):
        # find indices corresponding to i number of asterisks
        indices = [x for x, y in enumerate(stars) if y == i + 1]
        # then find the shifts corresponding to those indices and sort them in ascending order
        # the order in which the shifts appear don't matter, as long as they are paired correctly in calc and expt
        expt_sorted = expt[indices].sort_values().reset_index(drop=True)
        calc_sorted = calc[indices].sort_values().reset_index(drop=True)
        # so now we can access the sorted shifts with expt_sorted[j] where j ranges from 0 to i-1
        # and use a loop to replace the data in the original expt and calc Series
        for j in range(len(indices)):
            expt.loc[indices[j]] = expt_sorted[j]
            calc.loc[indices[j]] = calc_sorted[j]

    # generate sub-series for 13C and 1H chemical shifts from the overall series
    carbons = []
    hydrogens = []
    for index, atom in atoms.iteritems():
        if atom == "C" or index == "c":
            carbons.append(index)
        elif atom == "H" or index == "h":
            hydrogens.append(index)
    expt_c = expt[carbons]
    expt_h = expt[hydrogens]
    calc_c = calc[carbons]
    calc_h = calc[hydrogens]

    # perform empirical scaling of shifts. Calculated shifts are y-axis (slightly counterintuitive)
    c_slope, c_intercept, x4, x5, x6 = stats.linregress(expt_c, calc_c)
    h_slope, h_intercept, x7, x8, x9 = stats.linregress(expt_h, calc_h)
    scaled_calc_c = (calc_c - c_intercept) / c_slope
    scaled_calc_c.name = "scaled_calc_c"
    scaled_calc_h = (calc_h - h_intercept) / h_slope
    scaled_calc_h.name = "scaled_calc_h"

    # calculate errors
    c_errors = abs(expt_c - scaled_calc_c)
    c_errors.name = "c_errors"
    h_errors = abs(expt_h - scaled_calc_h)
    h_errors.name = "h_errors"

    # calculate probabilities
    c_probs = 1 - stats.t.cdf(c_errors, DF_13C, loc=0, scale=SD_13C)
    h_probs = 1 - stats.t.cdf(h_errors, DF_1H, loc=0, scale=SD_1H)
    total_c_prob = c_probs.prod()
    total_h_prob = h_probs.prod()
    total_combined_prob = total_c_prob * total_h_prob

    return [total_c_prob, total_h_prob, total_combined_prob]


def dp4(atoms, stars, expt, calc_df):
    # This function runs the DP4 analysis for a set of experimental data against a DF of experimental data.
    # It also prints some very nicely formatted output!

    # initialise stuff
    number_of_isomers = len(calc_df.columns) - 2
    product_probs_c = []
    product_probs_h = []
    product_probs_combined = []
    p_isomer_given_c_shifts = []
    p_isomer_given_h_shifts = []
    p_isomer_given_combined_shifts = []
    calc_name_str = ""
    product_probs_combined_str = ""
    product_probs_c_str = ""
    product_probs_h_str = ""
    p_combined_str = ""
    p_c_str = ""
    p_h_str = ""

    # print header
    print()
    print("=" * (14 + len(expt.name)))
    print("DP4 ANALYSIS: {}".format(expt.name))
    print("=" * (14 + len(expt.name)))
    print()

    # calculate P(shifts|structure), i.e. the product of probabilities of observing errors
    for j in range(number_of_isomers):
        c_prob, h_prob, combined_prob = calculate_dp4_probability(atoms,
                                                                  stars,
                                                                  expt.copy(),
                                                                  calc_df.iloc[:, j + 2].copy())
        # needs .copy() to avoid SettingWithCopyWarning later on (although there's no functional difference)
        product_probs_c.append(c_prob)
        product_probs_h.append(h_prob)
        product_probs_combined.append(combined_prob)

    # calculate P(structure|shifts), i.e. Bayes' theorem probabilities
    for k in range(number_of_isomers):
        p_isomer_given_c_shifts.append(product_probs_c[k] / sum(product_probs_c))
        p_isomer_given_h_shifts.append(product_probs_h[k] / sum(product_probs_h))
        p_isomer_given_combined_shifts.append(product_probs_combined[k] / sum(product_probs_combined))

        # generate strings for nice tabular output
        # string containing all names of calculated isomers
        calc_name_str = calc_name_str + fmt_string(calc_df.iloc[:, k + 2].name, output_precision + 1) + " "

        # strings containing all products of probabilities
        product_probs_combined_str = product_probs_combined_str \
                                     + fmt_float(product_probs_combined[k], output_precision) + "  "
        product_probs_c_str = product_probs_c_str + fmt_float(product_probs_c[k], output_precision) + "  "
        product_probs_h_str = product_probs_h_str + fmt_float(product_probs_h[k], output_precision) + "  "

        # strings containing Bayes theorem probabilities for each isomer
        p_combined_str = p_combined_str + fmt_float(p_isomer_given_combined_shifts[k], output_precision) + "  "
        p_c_str = p_c_str + fmt_float(p_isomer_given_c_shifts[k], output_precision) + "  "
        p_h_str = p_h_str + fmt_float(p_isomer_given_h_shifts[k], output_precision) + "  "

    # print output
    print("-" * (len(calc_name_str) + 21))  # Don't ask why 21. It's magic! Just try it and see.
    print("{}  ==>  {}".format(fmt_string(expt.name, 18), calc_name_str))
    print("-" * (len(calc_name_str) + 21))
    print("P(combined errors)     {}".format(product_probs_combined_str))
    print("P(13C errors)          {}".format(product_probs_c_str))
    print("P(1H errors)           {}".format(product_probs_h_str))
    print("-" * (len(calc_name_str) + 21))
    print("P(isomer, combined)    {}".format(p_combined_str))
    print("P(isomer, 13C)         {}".format(p_c_str))
    print("P(isomer, 1H)          {}".format(p_h_str))
    print("-" * (len(calc_name_str) + 21))
    print()

    return 0


def parse_data(filename, stars):
    # This reads a .txt file containing data (in the format specified at the top of this document)
    # and returns a DF containing all of it for further manipulation.

    with open(filename, "r") as file:
        line_number = 0
        data = []

        for line in file:
            line_number = line_number + 1
            # gets names of the isomers from header line
            if line_number == 1:
                names = ["label", "atom", "stars"] + line.split()
            # gets shifts from lines below, rejecting whitespace and comments
            if line_number > 1 and line.strip() and not line.strip().startswith("#"):
                asterisks = len(line.split()[0]) - len(line.split()[0].rstrip("*"))
                if not (len(line.split()) - 1 == len(names) - 3):
                    error_quit("Number of shifts in line {} of {} does not "
                               "match the number of names given.".format(line_number, filename))
                line_data = [line.split()[0], line.split()[0][0], asterisks] + [float(i) for i in line.split()[1:]]
                data.append(line_data)

        df = pd.DataFrame(data, columns=names)
        if not stars:
            df = df.drop(columns=["stars"])
        return df


if __name__ == '__main__':
    # get data from files
    calc_df = parse_data("dp4_calc.txt", False)
    expt_df = parse_data("dp4_expt.txt", True)

    # check for invalid number of columns
    if len(calc_df.columns) < 4:
        error_quit("Please provide at least two sets of calculated shifts for DP4 analysis.")
    if len(expt_df.columns) < 4:
        error_quit("Please provide at least one set of experimental shifts for DP4 analysis.")

    # print the parsed data
    print("===============")
    print("CALCULATED DATA")
    print("===============")
    print(calc_df)
    print()
    print("=================")
    print("EXPERIMENTAL DATA")
    print("=================")
    print(expt_df)

    # check for invalid rows in chemical shift data
    for i in range(len(calc_df)):
        if not calc_df['label'][i] == expt_df['label'][i].rstrip("*"):
            error_quit("Atom labels {} in dp4_calc.txt and {} in dp4_expt.txt do not match.".format(calc_df['label'][i],
                                                                                                    expt_df['label'][i]))
        if calc_df['atom'][i] not in ["C", "c", "H", "h"]:
            error_quit("Atom label {} in dp4_calc.txt does not begin with C/c/H/H.".format(calc_df['label'][i]))
        if expt_df['atom'][i] not in ["C", "c", "H", "h"]:
            error_quit("Atom label {} in dp4_expt.txt does not begin with C/c/H/H.".format(expt_df['label'][i]))

    # runs DP4 analysis for every column in the experimental data file
    for j in range(len(expt_df.columns) - 3):
        dp4(expt_df['atom'], expt_df['stars'], expt_df.iloc[:, j + 3], calc_df)

    print("Please cite: Smith, S. G.; Goodman, J. M. J. Am. Chem. Soc. 2010, 132 (37), 12946–12959.")
