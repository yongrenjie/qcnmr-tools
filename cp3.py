"""
This script performs CP3 analysis as described in Smith & Goodman, J. Org. Chem. 2009, 74 (12), 4597–4607.

The script requires two text files: calc.txt (containing the calculated shifts) and expt.txt (experimental shifts).
Both files must have the following format:
 - first a header line containing the names of the two isomers (e.g. for calculated shifts, you may want to specify here
   the connectivity or configuration of the molecule, or for experimental shifts, you may want to specify the major or
   minor diastereomer). The names must not contain any spaces, but whitespace before or after the names is fine.
 - the subsequent lines must contain: (1) an atom label which begins with either 'C', 'c', 'H', or 'h'; (2) the shifts
   for each isomer.
 - comment lines beginning with # are allowed, but only after the header line.

In both calc.txt and expt.txt, the atom labels MUST align exactly! Both files can be generated by copy-pasting relevant
cells from Excel into calc.txt directly. See calc.txt and expt.txt in this folder for a real-life example.

If the experimental shifts are the same (i.e. Delta_e = 0), the entire row will effectively be excluded from the
calculation. There is no explicit code for that, but x / 0 evaluates to NaN which behaves as zero in a sum, so it makes
no contribution to the CP3 value.

The output follows the Goodman paper quite closely and should be fairly self-explanatory. A and B are the two possible
assignments for each pair of isomers. CP3(A) and CP3(B) are the values of the CP3 parameter, evaluated for both possible
assignment. P(CP3|A) is the probability of observing both CP3(A) and CP3(B) given that A is the correct assignment (this
is simply the product of P(CP3(A)|A) and P(CP3(B)|A)). Then, P(A|CP3) is the probability of A being the correct
assignment given the CP3 values calculated for both assignments. This last number is the "confidence" that we have in
predicting a certain assignment, i.e. if P(A|CP3) is 0.95, then we can say that CP3 allows us to predict that assignment
A is correct with 95% certainty.

If desired, the output can be printed to a file: use "cp3.py > cp3.out" instead of just "cp3.py".

The input files may have more than two columns of shifts. In this case, the program will perform CP3 analysis for all
pairs of columns; so, for example, if there are three columsn, it will provide CP3 parameters for assigning the first
two columns of expt.txt to the first two columns of calc.txt, then it will do the same for the first and third columns
of both files, then again for the last two columns of both files.
This is only really useful if you already know which experimental shifts belong to which isomer and simply want to check
whether the calculated data allows for correct prediction of all pairs of diastereomers. DO NOT use this to try to
assign three sets of experimental data to three sets of computational data! The CP3 parameter is NOT designed for this
use! Instead, consider using the DP4 method instead.

The mean and standard deviations for CP3 distributions are obtained unchanged from the SI of Goodman's paper. Please
note that in theory, these numbers are sensitive to the method used and the training set.
"""

#!/usr/bin/env python3

import pandas as pd
import math
import sys
from scipy.stats import norm            # Needed for normal_cdf. Using math.erf rounds very small numbers to zero.

CORRECT_MEAN = [0.512, 0.547, 0.478]            # [Combined, 13C, 1H]
CORRECT_SD = [0.209, 0.253, 0.305]
INCORRECT_MEAN = [-0.637, -0.487, -0.786]
INCORRECT_SD = [0.499, 0.533, 0.835]


def error_quit(error_message):
    print()
    print("ERROR: {}".format(error_message))
    print("Exiting...")
    sys.exit()
    return 0


"""
def normal_cdf(x, mean, sd):
    return (1.0 + math.erf((x - mean)/(sd * math.sqrt(2))))/2
    # This turns very small numbers into zero, which can lead to some ZeroDivisionError.
    # e.g. normal_cdf(-10, 0, 0.5) returns 0.0, but scipy.stats.norm.cdf(-10, 0, 0.5) returns 2.7536241186061556e-89
"""


def fmt_float(fl):
    if -0.000001 < fl < 0.000001 and fl != 0:
        return "{:10.2e}".format(fl)
    else:
        return "{:10.6f}".format(fl)


def calculate_cp3_value(calc_a, calc_b, expt_a, expt_b):
    Delta_c = calc_a - calc_b
    Delta_e = expt_a - expt_b

    Dc_divide_De = pd.Series(Delta_c / Delta_e > 1)     # logical array
    sum_f3 = ((((Delta_e ** 3) / Delta_c) * Dc_divide_De) + ((Delta_e * Delta_c) * (1 - Dc_divide_De))).sum()
    sum_DeSquared = (Delta_e ** 2).sum()
    cp3 = sum_f3 / sum_DeSquared

    return cp3


def cp3(atoms, calc_a, calc_b, expt_a, expt_b):
    cp3_A = [0, 0, 0]
    cp3_B = [0, 0, 0]
    p_cp3_given_A = [0, 0, 0]
    p_cp3_given_B = [0, 0, 0]
    p_A_given_cp3 = [0, 0, 0]
    p_B_given_cp3 = [0, 0, 0]

    c13_logical_array = (atoms == 'C') | (atoms == 'c')
    h1_logical_array = (atoms == 'H') | (atoms == 'h')

    # calculate CP3 for assignment A (first calc column = first expt column)
    cp3_A[0] = calculate_cp3_value(calc_a, calc_b, expt_a, expt_b)
    cp3_A[1] = calculate_cp3_value(calc_a * c13_logical_array, calc_b * c13_logical_array,
                                   expt_a * c13_logical_array, expt_b * c13_logical_array)
    cp3_A[2] = calculate_cp3_value(calc_a * h1_logical_array, calc_b * h1_logical_array,
                                   expt_a * h1_logical_array, expt_b * h1_logical_array)
    # calculate CP3 for assignment B (first calc column = second expt column)
    cp3_B[0] = calculate_cp3_value(calc_a, calc_b, expt_b, expt_a)
    cp3_B[1] = calculate_cp3_value(calc_a * c13_logical_array, calc_b * c13_logical_array,
                                   expt_b * c13_logical_array, expt_a * c13_logical_array)
    cp3_B[2] = calculate_cp3_value(calc_a * h1_logical_array, calc_b * h1_logical_array,
                                   expt_b * h1_logical_array, expt_a * h1_logical_array)

    print()
    print("========================================================================")
    print()
    for i in range(3):      # i = 0 is combined; i = 1 is 13C; i = 2 is 1H
        # calculate probability of obtaining CP3 values given that assignment A is correct
        p_cp3_given_A[i] = min(norm.cdf(cp3_A[i], CORRECT_MEAN[i], CORRECT_SD[i]),
                               1 - norm.cdf(cp3_A[i], CORRECT_MEAN[i], CORRECT_SD[i])) * \
                           min(norm.cdf(cp3_B[i], INCORRECT_MEAN[i], INCORRECT_SD[i]),
                               1 - norm.cdf(cp3_B[i], INCORRECT_MEAN[i], INCORRECT_SD[i])) * 4
        # calculate probability of obtaining CP3 values given that assignment B is correct
        p_cp3_given_B[i] = min(norm.cdf(cp3_A[i], INCORRECT_MEAN[i], INCORRECT_SD[i]),
                               1 - norm.cdf(cp3_A[i], INCORRECT_MEAN[i], INCORRECT_SD[i])) * \
                           min(norm.cdf(cp3_B[i], CORRECT_MEAN[i], CORRECT_SD[i]),
                               1 - norm.cdf(cp3_B[i], CORRECT_MEAN[i], CORRECT_SD[i])) * 4
        # calculate probability of assignments A or B being correct given the CP3 values
        p_A_given_cp3[i] = p_cp3_given_A[i] / (p_cp3_given_A[i] + p_cp3_given_B[i])
        p_B_given_cp3[i] = p_cp3_given_B[i] / (p_cp3_given_A[i] + p_cp3_given_B[i])

    # print formatted output
    print("ASSIGNMENT A: ({}, {}) -> ({}, {})".format(expt_a.name, expt_b.name, calc_a.name, calc_b.name))
    print("ASSIGNMENT B: ({}, {}) -> ({}, {})".format(expt_b.name, expt_a.name, calc_a.name, calc_b.name))
    print()

    print("--------------------      --------------------      --------------------")
    print("Combined 13C and 1H       13C only                  1H only")
    print("--------------------      --------------------      --------------------")
    print("CP3(A)  : {}      CP3(A)  : {}      CP3(A)  : {}".format(fmt_float(cp3_A[0]),
                                                                    fmt_float(cp3_A[1]),
                                                                    fmt_float(cp3_A[2])))
    print("CP3(B)  : {}      CP3(B)  : {}      CP3(B)  : {}".format(fmt_float(cp3_B[0]),
                                                                    fmt_float(cp3_B[1]),
                                                                    fmt_float(cp3_B[2])))
    print()
    print("P(CP3|A): {}      P(CP3|A): {}      P(CP3|A): {}".format(fmt_float(p_cp3_given_A[0]),
                                                                    fmt_float(p_cp3_given_A[1]),
                                                                    fmt_float(p_cp3_given_A[2])))
    print("P(CP3|B): {}      P(CP3|B): {}      P(CP3|B): {}".format(fmt_float(p_cp3_given_B[0]),
                                                                    fmt_float(p_cp3_given_B[1]),
                                                                    fmt_float(p_cp3_given_B[2])))
    print()
    print("P(A|CP3): {}      P(A|CP3): {}      P(A|CP3): {}".format(fmt_float(p_A_given_cp3[0]),
                                                                    fmt_float(p_A_given_cp3[1]),
                                                                    fmt_float(p_A_given_cp3[2])))
    print("P(B|CP3): {}      P(B|CP3): {}      P(B|CP3): {}".format(fmt_float(p_B_given_cp3[0]),
                                                                    fmt_float(p_B_given_cp3[1]),
                                                                    fmt_float(p_B_given_cp3[2])))
    return 0


def parse_data(filename):
    with open(filename, "r") as file:
        line_number = 0
        data = []

        for line in file:
            line_number = line_number + 1
            # gets names of the isomers from header line
            if line_number == 1:
                names = ["label", "atom"] + line.split()
            # gets shifts from lines below, rejecting whitespace and comments
            if line_number > 1 and line.strip() and not line.strip().startswith("#"):
                if not (len(line.split()) - 1 == len(names) - 2):
                    error_quit("Number of shifts in line {} of {} does not "
                               "match the number of names given.".format(line_number, filename))
                line_data = [line.split()[0], line.split()[0][0]] + [float(i) for i in line.split()[1:]]
                data.append(line_data)

        return pd.DataFrame(data, columns=names)


if __name__ == '__main__':

    calc_df = parse_data("calc.txt")
    expt_df = parse_data("expt.txt")

    print("===============")
    print("CALCULATED DATA")
    print("===============")
    print(calc_df)
    print()
    print("=================")
    print("EXPERIMENTAL DATA")
    print("=================")
    print(expt_df)

    if len(calc_df.columns) != len(expt_df.columns):
        error_quit("Number of isomers in calc.txt and expt.txt differ.")
    for i in range(len(calc_df)):
        if not calc_df['label'][i] == expt_df['label'][i]:
            error_quit("Atom labels {} in calc.txt and {} in expt.txt do not match.".format(calc_df['label'][i],
                                                                                            expt_df['label'][i]))
        if calc_df['atom'][i] not in ["C", "c", "H", "h"]:
            error_quit("Atom label {} in calc.txt does not begin with C/c/H/H.".format(calc_df['label'][i]))
        if expt_df['atom'][i] not in ["C", "c", "H", "h"]:
            error_quit("Atom label {} in expt.txt does not begin with C/c/H/H.".format(expt_df['label'][i]))


    number_of_isomers = len(calc_df.columns) - 2

    for m in range(number_of_isomers):
        for n in range(number_of_isomers):
            if n > m:
                # Runs CP3 analysis for all pairs of columns in calculated/experimental data
                cp3(calc_df['atom'], calc_df.iloc[:, m + 2], calc_df.iloc[:, n + 2],
                    expt_df.iloc[:, m + 2], expt_df.iloc[:, n + 2])

    print()
    print("========================================================================")
    print()
    print("Please cite: Smith, S. G.; Goodman, J. M. J. Org. Chem. 2009, 74 (12), 4597–4607.")

